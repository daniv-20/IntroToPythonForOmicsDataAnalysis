---
title: "Working with Tiff files"
author: "Dani V"
format: 
  html:
    toc: true
execute: 
  echo: fenced
  eval: false
  freeze: auto
---

## TIFF Files
TIFF (Tagged Image File Format) files are often used in imaging/microscopy and can be up to multible Gb in size, which can make them annoying to work with. Here are some things you might find useful when working with large TIFF files. TIFF files store images as grids of pizels and can contain multiple sub-images or layers within a single file. In image data like MxIF or H&E images, different channels can be stored on different layers. 

## OME-TIFF
An OME-TIFF (.ome.tiff/.ome.tif) is a TIFF-based format developed by the [Open Microscopy Environment (OME) consortium](https://www.openmicroscopy.org/) as a standard format for supporting microscopy images with metadata (ex: channels, z-stacks, multiple timepoints, px-to-micron conversion factor). 

## Pyramidal TIFF
Some TIFF images (called pyramid or multi-resolution tiffs) have the same image stored at multiple resolutions within the same file. This is typically done for very large images (like full-slide images) to allow users to quickly render a downsampled version of the image for easy viewing and load higher resolution versions of the image only when necessary. 


## Example Code for working with TIFF images
Below are some example functions and script fragments that may be useful when working with pyramidal tiff images. 

### Example images
Below are some example TIFF or OME TIFF images that can be used for testing: 
Some example OME tiff images can be found here: https://docs.openmicroscopy.org/ome-model/5.6.3/ome-tiff/data.html.   

For larger test images, the LuCa-7color images are good options: https://qupath.readthedocs.io/en/stable/docs/intro/acknowledgements.html  

### Extract Downscaled images
To read in tiff images and extract the downscaled versions, we can use the following code. 
[Dependencies: `tifffile`, `imagecodecs`].

```{python}
#| eval: true
#!/usr/bin/env python3
import os
import tifffile
import numpy as np

def read_pyramid_level(tiff_path, level=1):
    """
    Read a specified pyramid (downscale) level from an OME-TIFF file.
    level = 0 → full resolution, level = 1 → first downscale, etc.
    Returns: (image_array, resolution_info)
    """
    with tifffile.TiffFile(tiff_path) as tif:
        series = tif.series[0]
        if hasattr(series, 'levels'):
            levels = series.levels
            if level < len(levels):
                arr = levels[level].asarray()
                info = {
                    'shape': arr.shape,
                    'level_index': level,
                    'total_levels': len(levels)
                }
                return arr, info
            else:
                raise IndexError(f"Pyramid level {level} not found; only {len(levels)} levels available.")
        else:
            raise ValueError("No pyramid levels stored in this file.")
```

### To read downscaled image and display in python
Requres `read_pyramid_level()` above. 

```{python}
import os
import tifffile
import numpy as np
import matplotlib.pyplot as plt

def view_image(array, title=None, cmap=None):
    """
    Display a numpy image array using matplotlib.
    Automatically handles grayscale vs color.
    """
    plt.figure(figsize=(8,8))
    if cmap is None:
        # choose grayscale if 2D
        cmap_choice = 'gray' if array.ndim == 2 else None
    else:
        cmap_choice = cmap
    plt.imshow(array, cmap=cmap_choice)
    plt.axis('off')
    if title:
        plt.title(title)
    plt.show()

if __name__ == "__main__":
    path = "path/to/tiff"
    level_to_show = 1  # change as needed

    try:
        img_down, info = read_pyramid_level(path, level=level_to_show)
        print(f"Showing level {info['level_index']} of {info['total_levels']} (shape = {info['shape']})")
        view_image(img_down, title=f"Down-scale level {info['level_index']}")
    except Exception as e:
        print("Error reading/displaying image:", e)


```


### To save downscaled images as separate tiff files
Requres `read_pyramid_level()` above. 

```{python}
#| eval: false
import os
import tifffile
import numpy as np
def process_directory(base_folder, out_folder, level=1, extensions=('.tif','.tiff','.ome.tiff','.ome.tif')):
    """
    Walks through base_folder, finds files with given extensions, reads the requested pyramid level,
    and writes a downscaled image (or otherwise reports error).
    """
    os.makedirs(out_folder, exist_ok=True)
    for root, dirs, files in os.walk(base_folder):
        for fname in files:
            if fname.lower().endswith(extensions):
                in_path = os.path.join(root, fname)
                rel = os.path.relpath(in_path, base_folder)
                out_sub = os.path.join(out_folder, os.path.dirname(rel))
                os.makedirs(out_sub, exist_ok=True)
                out_name = os.path.splitext(os.path.basename(rel))[0] + f"_level{level}.tif"
                out_path = os.path.join(out_sub, out_name)
                try:
                    img_down, info = read_pyramid_level(in_path, level=level)
                    print(f"Read {in_path} → level {info['level_index']}/{info['total_levels']-1}, shape={info['shape']}")
                    # Write the result (you might want to adjust dtype/compression etc)
                    tifffile.imwrite(out_path, img_down, compression='zlib') # <1>
                    print(f"Wrote downscaled image to {out_path}")
                except Exception as e:
                    print(f"Error processing {in_path}: {e}")

if __name__ == "__main__":
    base_folder = "Image_Directory" ## directory where the tiff images are stored
    out_folder  = "Downscaled_Levels"
    level_to_extract = 1  # change as desired: 0 = full res, 1 = first downscale
    process_directory(base_folder, out_folder, level=level_to_extract)


```
1. Include this line to write the downscaled image to a new tiffile

### To make a pyramidal tiff out of a non-pyramid tiff
If you do not have a pyramid tiff, you can make one by calculating multiple resolutions 

```{python}
import numpy as np
from tifffile import imread, TiffWriter
from skimage.transform import rescale

in_path = "input.tif"
out_path = "output_pyramid.tif"

# --------------------------------------
# 1. Read input TIFF
# --------------------------------------
img = imread(in_path)  # shape (Y, X) or (Y, X, C)
print("Input shape:", img.shape)

# Ensure float for rescaling, then cast back later
img = img.astype("float32")

# --------------------------------------
# 2. Build pyramid levels
#    e.g. full, 1/2, 1/4, 1/8
# --------------------------------------
scales = [1.0, 0.5, 0.25, 0.125]  # you can change this
levels = []

for s in scales:
    if s == 1.0:
        level = img
    else:
        # rescale spatial dims; preserve_range keeps original intensity scale
        level = rescale(
            img,
            scale=(s, s, 1) if img.ndim == 3 else (s, s),
            anti_aliasing=True,
            preserve_range=True,
        ).astype("float32")
    levels.append(level)
    print(f"Level scale {s}: shape {level.shape}")

# Cast back to a suitable dtype (e.g. uint8 or uint16)
# Here I assume uint8; adapt if your data is 16-bit
levels = [np.clip(lvl, 0, 255).astype("uint8") for lvl in levels]

# --------------------------------------
# 3. Write pyramidal TIFF using tifffile
# --------------------------------------
# - tile=(256, 256) creates a tiled image (better for large images)
# - subifds=len(levels)-1 declares the number of subresolution images
# - subsequent writes use subfiletype=1 to mark them as reduced-resolution
# --------------------------------------

with TiffWriter(out_path, bigtiff=True) as tif:
    # Write the full-res level, declare subIFDs
    tif.write(
        data=levels[0],
        tile=(256, 256),
        subifds=len(levels) - 1,
        photometric="rgb" if (img.ndim == 3 and img.shape[-1] in (3, 4)) else "minisblack",
    )

    # Write each lower-res level as a subIFD
    for lvl in levels[1:]:
        tif.write(
            data=lvl,
            tile=(256, 256),
            subfiletype=1,  # reduced-resolution
            photometric="rgb" if (img.ndim == 3 and img.shape[-1] in (3, 4)) else "minisblack",
        )

print("Saved pyramidal TIFF to:", out_path)

```