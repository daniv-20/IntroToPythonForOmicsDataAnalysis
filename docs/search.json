[
  {
    "objectID": "gettingstarted.html",
    "href": "gettingstarted.html",
    "title": "Getting Started with Python",
    "section": "",
    "text": "This tutorial explains some ways to get started with using Python, including installation, setup, IDEs, and virtual environments (venv/conda, I prefer venv, many use conda).\nThis is a bare-bones tutorial, but there are others out there that explain these things in more depth. This tutorial assumes you have the ability to download and install files on your machine, which may not be true for some organization managed devices/compute clusters!"
  },
  {
    "objectID": "gettingstarted.html#aside-setting-up-your-ide---quality-of-life-things",
    "href": "gettingstarted.html#aside-setting-up-your-ide---quality-of-life-things",
    "title": "Getting Started with Python",
    "section": "Aside: Setting up your IDE - Quality of life things",
    "text": "Aside: Setting up your IDE - Quality of life things\nMany IDEs (including Positron, VSCode and RStudio) are very customizable, so I encourage you to take some time to explore your IDE of choice and set it up in a way that feels comfortable to use. Some IDEs also let you transfer customizations between machines via setting up an account or profile.\nSome things to customize include:\n- Theme (ex: dark mode/light mode)\n- Extensions (ex: csv viewer, pdf viewer, Quarto, Github)\n- Editor Layout (ex: console, terminal, plot viewer, variables)\nAs you spend more time using your IDE you can change your customizations to better suit your needs.\nFor those using Positron/VS Code I would recommend the following extensions:\n- Jupyter\n- Github Pull Requests\n- Quarto\nJupyter notebooks and quarto documents both allow you to combine code chunks with normal text. (I also built this website with Quarto!!) Having a csv viewer in your IDE is helpful, but not a requirement.\nIt is also possible to configure your IDE to play well with git/github and allow remote-ssh to a compute cluster (see Step 4: SSH to Host)."
  },
  {
    "objectID": "gettingstarted.html#creating-a-project-folder",
    "href": "gettingstarted.html#creating-a-project-folder",
    "title": "Getting Started with Python",
    "section": "Creating a Project Folder",
    "text": "Creating a Project Folder\nFocusing on Positron/VSCode (the user interface looks almost identical for both of them), you would typically start a project by opening or creating a project folder.\nFor now, create a folder called ‘BeginningPython’ and open it in your IDE.\n\n\nCreating/Opening a folder in Positron\n\n\nFrom initial startup screen\n\nTo create a new folder, click the ‘New Folder’ icon shown below.\n\n\n\nNew Folder Icon\n\n\nTo open a folder in Positron, you click the ‘Open Folder’ icon shown below.\n\n\n\nOpen Folder Icon"
  },
  {
    "objectID": "gettingstarted.html#creating-a-python-script",
    "href": "gettingstarted.html#creating-a-python-script",
    "title": "Getting Started with Python",
    "section": "Creating a python script",
    "text": "Creating a python script\nPython scripts use the extension .py. To create a Python script in your IDE, click on the New File icon and, in the new file’s name bar, type first_python.py.\nTo open this new file, click on it.\n\nAside: Because the .py extension is what tells the computer that a file is supposed to be a python script, it is technically possible to create python scripts in a simple text editor by naming the file with the .py extension.\n\nTo get started, let’s write a simple print statement and do some basic math.\nIn your python script, write the following.\nprint(\"hello world\")\n\nx = 1\ny = -7\n\n1print(f\"x - y = {x-y}\")\n\n1\n\nThe ‘f’ is not a typo! This is an f string, which lets us add results into a print statement. We’ll discuss f-strings later."
  },
  {
    "objectID": "gettingstarted.html#running-python-scripts",
    "href": "gettingstarted.html#running-python-scripts",
    "title": "Getting Started with Python",
    "section": "Running Python Scripts",
    "text": "Running Python Scripts\nThere are multiple ways to run your python script. If you are working in Positron, you can highlight the lines of code you want to run and press ctrl + return (true for Windows and MacOS).\nThe method above is best for running a few lines at a time. To run the full file, click the ‘run’ button on your IDE. In Positron, it’s typically located at the top left (right below the python script tab).\n\n\n\nRun Button\n\n\nAfter running the demo code, you get:\n\nprint(\"hello world\")\n\nx = 1\ny = -7\n\nprint(f\"x - y = {x-y}\")\n\nhello world\nx - y = 8\n\n\n\nFrom command line/terminal\nYou can also run python scripts from the command line. If you are using Positron, click on the “TERMINAL” tab. In the terminal, you should see the name of your working directory (the folder your ‘first_python.py’ document is in.)\n\n\n\nTerminal Tab\n\n\nThe ‘scripting language’ of the terminal is called ‘bash’ for Unix-like systems (MacOS, Linux) and typically ‘powershell’ for windows.\n\npython first_python.py\nIf you are working on MAC, you might have to do python3 first_python.py instead.\n\n\nWith a bash script (.sh file)\nFinally, you can run one or multiple python files using a bash script (.sh file). This is a bit more involved so it will be included in another tutorial link will be here when available."
  },
  {
    "objectID": "gettingstarted.html#step-4-optional-ssh-to-host-positron",
    "href": "gettingstarted.html#step-4-optional-ssh-to-host-positron",
    "title": "Getting Started with Python",
    "section": "Step 4 (Optional): SSH to Host (Positron)",
    "text": "Step 4 (Optional): SSH to Host (Positron)\nIf you work with an internal server/compute cluster that you access via SSH (if this does not apply to you feel free to skip this part), you can connect to it via Remote-SSH in Positron. Please note that this will only work if you have the correct permissions for the remote host!\nThere are two ways to connect Positron to a remote host. The fast way is to click the little &gt;&lt; icon at the bottom left of the screen . Mine is pink, yours may be another color depending on your theme. This will take you directly to the options to Connect to Host, Connect Current Window to Host or Update SSH Configuration . Click Connect Current Window to Host and put the username you use to connect to your compute cluster and then hit enter and type your password.\nThe first time you connect to the host, it will take some time as positron needs to be installed on the host. After that, the connection will be much faster.\nThe other option to connect via Remote-SSH is to click on the search bar add img and click show and run commands. add img or press ctrl+shift+P (cmd+shift+P on mac). This opens the commands panel in which you can type SSH and click on Remote-SSH: Connect Current Window to Host add img. There you put the username you use to connect to your compute cluster and then hit enter and type your password.\n\nRunning Python Scripts on the remote host\nOnce you have connected to the remote host, you should be able to create and run python scripts there in the same manner as on your local machine (provided you have the necessary permissions).\n\n\n\n\n\n\nWarningYou can only see files on the host that are stored on a drive the host sees.\n\n\n\nIf you want to run a file from your local machine on the host machine, you need to upload that file (and the necessary data etc.) to the host machine.\n\n\nYou can download files/folders from the host machine to your machine by right-clicking (ctrl+click on mac) and then clicking download."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About this Site",
    "section": "",
    "text": "The purpose of this website is to serve as a resource guide and set of notes/tutorials for ‘omics analysis’ in Python. This includes working with packages/programs that are geared towards omics analysis and interfacing with things like QuPath in python.\nI’m trying to make this as detailed as possible, so you should not have to know anything about programming to get started! I will link back to past tutorials and other resources during explanations of more complicated topics to keep things less wordy.\nFeel free to make use of the search function to find the information most relevant to you!\nDisclaimer: I am mostly self-taught and I can make mistakes. Please look into the methods yourself before using them in your research."
  },
  {
    "objectID": "programminginpython.html",
    "href": "programminginpython.html",
    "title": "Programming in Python",
    "section": "",
    "text": "This tutorial assumes you have Python installed on your computer and an IDE you are comforable with using. I use Positron, so some information may be Positron-specific. No prior programming knowledge is necessary.\nIf you have no prior knowledge in programming, please click the drop-down below for a brief explanation of how programming works and some tips that I find useful."
  },
  {
    "objectID": "programminginpython.html#programming-paradigms---object-oriented-vs-functional",
    "href": "programminginpython.html#programming-paradigms---object-oriented-vs-functional",
    "title": "Programming in Python",
    "section": "Programming Paradigms - Object-Oriented vs Functional",
    "text": "Programming Paradigms - Object-Oriented vs Functional\nThe Python libraries (packages) used in Omics analysis tend to be very ‘object-oriented’, meaning that they harness the properties of ‘objects’ rather than ‘functions’.\nHere, objects are instances (individual items) of classes (blueprints) that contain attributes (data/information) and methods (instructions), while functions are a set of steps to be performed and are not limited to acting on/being associated with a certain object.\nMost programming languages lend themselves to either object-oriented or functional programming (or both) and programmers that specialize in these languages tend to prefer one paradigm or another.\nMost python programmers and library developers use object-oriented."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Resource Guide on Python for Omics Analysis",
    "section": "",
    "text": "About this Site\nThe purpose of this website is to serve as a resource guide and set of notes/tutorials for ‘omics analysis’ in Python. This includes working with packages/programs that are geared towards omics analysis (eg scanpy) and interfacing with things like QuPath in python (woo geojson!!).\nMost tutorials will be in quarto or jupyter notebook format and will have code-copy enabled!\nThere is a ‘getting started’ tutorial for anyone who has never used Python before and I will include links to other tutorials/resources within all of my tutorials so please do not be afraid to jump right in!\nCheck out the reference parking lot for links to packages etc. that are interesting or might be helpful for omics analysis.\nAs a general disclaimer: I am not promising that the way I do things is the best (or most up-to-date) way! I am mostly self-taught in terms of programming and I’ll be including new-to-me methods as I learn them.",
    "crumbs": [
      "Home",
      "A Resource Guide on Python for Omics Analysis"
    ]
  },
  {
    "objectID": "refdump.html",
    "href": "refdump.html",
    "title": "Reference Parking Lot",
    "section": "",
    "text": "This is a searchable dump of references I’ve found useful. I will try to add reference descriptions/tags when I can, but please don’t expect much organization here.\nThe references are grouped into broad categories under headings."
  },
  {
    "objectID": "refdump.html#segmentation",
    "href": "refdump.html#segmentation",
    "title": "Reference Parking Lot",
    "section": "Segmentation",
    "text": "Segmentation\ncellpose. Supposedly better than stardist in some cases. Still investigating this."
  },
  {
    "objectID": "WorkingWithTiffs.html",
    "href": "WorkingWithTiffs.html",
    "title": "Working with Tiff files",
    "section": "",
    "text": "TIFF (Tagged Image File Format) files are often used in imaging/microscopy and can be up to multible Gb in size, which can make them annoying to work with. Here are some things you might find useful when working with large TIFF files. TIFF files store images as grids of pizels and can contain multiple sub-images or layers within a single file. In image data like MxIF or H&E images, different channels can be stored on different layers."
  },
  {
    "objectID": "WorkingWithTiffs.html#tiff-files",
    "href": "WorkingWithTiffs.html#tiff-files",
    "title": "Working with Tiff files",
    "section": "",
    "text": "TIFF (Tagged Image File Format) files are often used in imaging/microscopy and can be up to multible Gb in size, which can make them annoying to work with. Here are some things you might find useful when working with large TIFF files. TIFF files store images as grids of pizels and can contain multiple sub-images or layers within a single file. In image data like MxIF or H&E images, different channels can be stored on different layers."
  },
  {
    "objectID": "WorkingWithTiffs.html#ome-tiff",
    "href": "WorkingWithTiffs.html#ome-tiff",
    "title": "Working with Tiff files",
    "section": "OME-TIFF",
    "text": "OME-TIFF\nAn OME-TIFF (.ome.tiff/.ome.tif) is a TIFF-based format developed by the Open Microscopy Environment (OME) consortium as a standard format for supporting microscopy images with metadata (ex: channels, z-stacks, multiple timepoints, px-to-micron conversion factor)."
  },
  {
    "objectID": "WorkingWithTiffs.html#pyramidal-tiff",
    "href": "WorkingWithTiffs.html#pyramidal-tiff",
    "title": "Working with Tiff files",
    "section": "Pyramidal TIFF",
    "text": "Pyramidal TIFF\nSome TIFF images (called pyramid or multi-resolution tiffs) have the same image stored at multiple resolutions within the same file. This is typically done for very large images (like full-slide images) to allow users to quickly render a downsampled version of the image for easy viewing and load higher resolution versions of the image only when necessary."
  },
  {
    "objectID": "WorkingWithTiffs.html#example-code-for-working-with-tiff-images",
    "href": "WorkingWithTiffs.html#example-code-for-working-with-tiff-images",
    "title": "Working with Tiff files",
    "section": "Example Code for working with TIFF images",
    "text": "Example Code for working with TIFF images\nBelow are some example functions and script fragments that may be useful when working with pyramidal tiff images.\n\nExample images\nBelow are some example TIFF or OME TIFF images that can be used for testing: Some example OME tiff images can be found here: https://docs.openmicroscopy.org/ome-model/5.6.3/ome-tiff/data.html.\nFor larger test images, the LuCa-7color images are good options: https://qupath.readthedocs.io/en/stable/docs/intro/acknowledgements.html\n\n\nExtract Downscaled images\nTo read in tiff images and extract the downscaled versions, we can use the following code. [Dependencies: tifffile, imagecodecs].\n```{python}\n#| eval: true\n#!/usr/bin/env python3\nimport os\nimport tifffile\nimport numpy as np\n\ndef read_pyramid_level(tiff_path, level=1):\n    \"\"\"\n    Read a specified pyramid (downscale) level from an OME-TIFF file.\n    level = 0 → full resolution, level = 1 → first downscale, etc.\n    Returns: (image_array, resolution_info)\n    \"\"\"\n    with tifffile.TiffFile(tiff_path) as tif:\n        series = tif.series[0]\n        if hasattr(series, 'levels'):\n            levels = series.levels\n            if level &lt; len(levels):\n                arr = levels[level].asarray()\n                info = {\n                    'shape': arr.shape,\n                    'level_index': level,\n                    'total_levels': len(levels)\n                }\n                return arr, info\n            else:\n                raise IndexError(f\"Pyramid level {level} not found; only {len(levels)} levels available.\")\n        else:\n            raise ValueError(\"No pyramid levels stored in this file.\")\n```\n\n\nTo read downscaled image and display in python\nRequres read_pyramid_level() above.\n```{python}\n#| eval: true\nimport os\nimport tifffile\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef view_image(array, title=None, cmap=None):\n    \"\"\"\n    Display a numpy image array using matplotlib.\n    Automatically handles grayscale vs color.\n    \"\"\"\n    plt.figure(figsize=(8,8))\n    if cmap is None:\n        # choose grayscale if 2D\n        cmap_choice = 'gray' if array.ndim == 2 else None\n    else:\n        cmap_choice = cmap\n    plt.imshow(array, cmap=cmap_choice)\n    plt.axis('off')\n    if title:\n        plt.title(title)\n    plt.show()\n\nif __name__ == \"__main__\":\n    path = \"quarto\\NIRHTa-001.ome.tiff\"\n    level_to_show = 1  # change as needed\n\n    try:\n        img_down, info = read_pyramid_level(path, level=level_to_show)\n        print(f\"Showing level {info['level_index']} of {info['total_levels']} (shape = {info['shape']})\")\n        view_image(img_down, title=f\"Down-scale level {info['level_index']}\")\n    except Exception as e:\n        print(\"Error reading/displaying image:\", e)\n\n\n```\n\n\nTo save downscaled images as separate tiff files\nRequres read_pyramid_level() above.\n```{python}\n#| eval: false\nimport os\nimport tifffile\nimport numpy as np\ndef process_directory(base_folder, out_folder, level=1, extensions=('.tif','.tiff','.ome.tiff','.ome.tif')):\n    \"\"\"\n    Walks through base_folder, finds files with given extensions, reads the requested pyramid level,\n    and writes a downscaled image (or otherwise reports error).\n    \"\"\"\n    os.makedirs(out_folder, exist_ok=True)\n    for root, dirs, files in os.walk(base_folder):\n        for fname in files:\n            if fname.lower().endswith(extensions):\n                in_path = os.path.join(root, fname)\n                rel = os.path.relpath(in_path, base_folder)\n                out_sub = os.path.join(out_folder, os.path.dirname(rel))\n                os.makedirs(out_sub, exist_ok=True)\n                out_name = os.path.splitext(os.path.basename(rel))[0] + f\"_level{level}.tif\"\n                out_path = os.path.join(out_sub, out_name)\n                try:\n                    img_down, info = read_pyramid_level(in_path, level=level)\n                    print(f\"Read {in_path} → level {info['level_index']}/{info['total_levels']-1}, shape={info['shape']}\")\n                    # Write the result (you might want to adjust dtype/compression etc)\n1                    tifffile.imwrite(out_path, img_down, compression='zlib')\n                    print(f\"Wrote downscaled image to {out_path}\")\n                except Exception as e:\n                    print(f\"Error processing {in_path}: {e}\")\n\nif __name__ == \"__main__\":\n    base_folder = \"Image_Directory\" ## directory where the tiff images are stored\n    out_folder  = \"Downscaled_Levels\"\n    level_to_extract = 1  # change as desired: 0 = full res, 1 = first downscale\n    process_directory(base_folder, out_folder, level=level_to_extract)\n\n```\n\n1\n\nInclude this line to write the downscaled image to a new tiffile"
  }
]